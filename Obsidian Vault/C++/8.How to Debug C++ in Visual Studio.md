# 断点和查看内存
## 断点（breakpoint）
当程序执行到打上断点的这一行时，程序会暂停，悬停该执行线程（程序），从而可以查看运行的状态，也就是查看内存（memory）
## 内存（memory）
一个正在执行的程序，在内存上几乎可以反映一切，查看变量的设置，查看函数的执行
## Debug
使用断点debug时，一点更要选择debug模式而不能选择release，release会重构代码
# 断点调试
断点打在某一行时，程序会运行到该行代码前，而该行代码尚未运行
打上断点并运行后出现 step into（逐语句）、step over（逐过程）、step out（跳出）三个按键
## step into（逐语句）（F11）
依据实际运行的语句，逐行执行程序
如果当前行为函数，则点击后进入到函数中逐句运行，第一次点击step into，会设置该*函数堆栈框架*，此时函数会接收到外部的输入，再次点击step into，执行函数的第一行，以此类推
## step out（跳出）（Shift+F11）
跳出当前函数，回到call这个函数的地方（执行到当前函数结束）
## step over（逐过程）（F10）
依据断点处的语句，逐行执行程序
## 调试过程
1. 当断点打在某处，并运行到此处时，断点之上会有一个黄色的箭头指向该行，但程序还未运行到该行
2. 当断点打在某函数第一行或逐语句进入到某函数第一行时，此时黄色箭头指向该行，同理该行并未运行，但程序已经进入该函数，设置了函数堆栈框架，输入变量已经被赋值
# 查看内存
断点模式下，有三个查看内存的窗口，Autos（自动窗口）、Locals（局部变量）、监视（Watch），可在调试->窗口中找到；以及直接查看内存的Memory（内存）窗口。窗口内右键可以选择十六进制显示
## Autos（自动窗口）
展示某些重要的变量
## Locals（局部变量）
展示某些重要的局部变量
## Watch（监视）
自定义监视的变量
## Memory（内存）
1. 在调试->窗口中找到，输入地址，左侧查看对应的内存，右侧查看对应的ASCII解码，输入地址时对于变量可以使用取地址符号“&”（&a）
2. debug模式中，会在变量*初始化之前*将所占用的字节全部转化为“cc”（十六进制HEX，两个十六进制数字正好代表一个字节），方便调试时查看内存，所以“cc”表示*未初始化的堆栈内存*。以上内容仅适用于debug模式，也是debug模式相对较慢的原因（做一些额外的事情以方便调试）
3. 内存发生改变时，在内存窗口中对应的位置会标红，表示该内存在上一步运行时改变
### 对于指针变量
1. 可以在监视窗口中找到指针变量的值，也就是其存储的地址（后面也会显示其指向的变量的值）
2. 在内存窗口中直接输入&a，看到的是a所存储的地址信息，以十六进制显示，但顺序是小端在前，而内存窗口中的地址输入是大端在前
